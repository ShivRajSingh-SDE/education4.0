{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) : typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) : factory(global.THREE = global.THREE || {}, global.THREE);\n})(this, function (exports, three) {\n  'use strict';\n\n  /**\n   * get variable type\n   * @param {*} val a variable which you want to get the type\n   * @return {String} variable-type\n   */\n  function _rt(val) {\n    return Object.prototype.toString.call(val);\n  }\n\n  /**\n   * Utils tool box\n   *\n   * @namespace Utils\n   */\n  var Utils = {\n    /**\n     * determine whether it is a `Function`\n     *\n     * @static\n     * @method\n     * @memberof Utils\n     * @param {*} variable a variable which you want to determine\n     * @return {Boolean} type result\n     */\n    isFunction: function () {\n      var ks = _rt(function () {});\n      return function (variable) {\n        return _rt(variable) === ks;\n      };\n    }(),\n    /**\n     * determine whether it is a `undefined`\n     *\n     * @static\n     * @method\n     * @memberof Utils\n     * @param {*} variable a variable which you want to determine\n     * @return {Boolean} type result\n     */\n    isUndefined: function isUndefined(variable) {\n      return typeof variable === 'undefined';\n    }\n  };\n\n  /**\n   * proxy `addEventListener` function\n   *\n   * @param {String} type event type, evnet name\n   * @param {Function} fn callback\n   * @return {this} this\n   */\n  three.EventDispatcher.prototype.on = function (type, fn) {\n    if (!Utils.isFunction(fn)) return;\n    if (this instanceof three.Object3D) this.interactive = true;\n    this.addEventListener(type, fn);\n    return this;\n  };\n\n  /**\n   * proxy `removeEventListener` function\n   *\n   * @param {String} type event type, evnet name\n   * @param {Function} fn callback, which you had bind before\n   * @return {this} this\n   */\n  three.EventDispatcher.prototype.off = function (type, fn) {\n    this.removeEventListener(type, fn);\n    return this;\n  };\n\n  /**\n   * binding a once event, just emit once time\n   *\n   * @param {String} type event type, evnet name\n   * @param {Function} fn callback\n   * @return {this} this\n   */\n  three.EventDispatcher.prototype.once = function (type, fn) {\n    var _this = this;\n    if (!Utils.isFunction(fn)) return;\n    var cb = function cb(ev) {\n      fn(ev);\n      _this.off(type, cb);\n    };\n    this.on(type, cb);\n    return this;\n  };\n\n  /**\n   * emit a event\n   *\n   * @param {String} type event type, evnet name\n   * @return {this} this\n   */\n  three.EventDispatcher.prototype.emit = function (type) {\n    if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n    var cbs = this._listeners[type] || [];\n    var cache = cbs.slice(0);\n    for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      argument[_key - 1] = arguments[_key];\n    }\n    for (var i = 0; i < cache.length; i++) {\n      cache[i].apply(this, argument);\n    }\n    return this;\n  };\n\n  /**\n   * whether displayObject is interactively\n   */\n  three.Object3D.prototype.interactive = false;\n\n  /**\n   * whether displayObject's children is interactively\n   */\n  three.Object3D.prototype.interactiveChildren = true;\n\n  /**\n   * whether displayObject had touchstart\n   * @private\n   */\n  three.Object3D.prototype.started = false;\n\n  /**\n   * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n   */\n  Object.defineProperty(three.Object3D.prototype, 'trackedPointers', {\n    get: function get() {\n      if (!this._trackedPointers) this._trackedPointers = {};\n      return this._trackedPointers;\n    }\n  });\n\n  /**\n   * dispatch a raycast\n   *\n   * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n   * @return {Object|Boolean} had pass hit-test\n   */\n  three.Object3D.prototype.raycastTest = function (raycaster) {\n    var result = [];\n    this.raycast(raycaster, result);\n    if (result.length > 0) {\n      return result[0];\n    }\n    return false;\n  };\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  var inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n  var possibleConstructorReturn = function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  /**\n   * Holds all information related to an Interaction event\n   *\n   * @class\n   */\n\n  var InteractionData = function () {\n    /**\n     * InteractionData constructor\n     */\n    function InteractionData() {\n      classCallCheck(this, InteractionData);\n\n      /**\n       * This point stores the global coords of where the touch/mouse event happened\n       *\n       * @member {Vector2}\n       */\n      this.global = new three.Vector2();\n\n      /**\n       * The target DisplayObject that was interacted with\n       *\n       * @member {Object3D}\n       */\n      this.target = null;\n\n      /**\n       * When passed to an event handler, this will be the original DOM Event that was captured\n       *\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n       * @member {MouseEvent|TouchEvent|PointerEvent}\n       */\n      this.originalEvent = null;\n\n      /**\n       * Unique identifier for this interaction\n       *\n       * @member {number}\n       */\n      this.identifier = null;\n\n      /**\n       * Indicates whether or not the pointer device that created the event is the primary pointer.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n       * @type {Boolean}\n       */\n      this.isPrimary = false;\n\n      /**\n       * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n       * @type {number}\n       */\n      this.button = 0;\n\n      /**\n       * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n       * @type {number}\n       */\n      this.buttons = 0;\n\n      /**\n       * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n       * radiusX of TouchEvents will be represented by this value.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n       * @type {number}\n       */\n      this.width = 0;\n\n      /**\n       * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n       * radiusY of TouchEvents will be represented by this value.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n       * @type {number}\n       */\n      this.height = 0;\n\n      /**\n       * The angle, in degrees, between the pointer device and the screen.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n       * @type {number}\n       */\n      this.tiltX = 0;\n\n      /**\n       * The angle, in degrees, between the pointer device and the screen.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n       * @type {number}\n       */\n      this.tiltY = 0;\n\n      /**\n       * The type of pointer that triggered the event.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n       * @type {string}\n       */\n      this.pointerType = null;\n\n      /**\n       * Pressure applied by the pointing device during the event. A Touch's force property\n       * will be represented by this value.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n       * @type {number}\n       */\n      this.pressure = 0;\n\n      /**\n       * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n       * @type {number}\n       */\n      this.rotationAngle = 0;\n\n      /**\n       * Twist of a stylus pointer.\n       * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n       * @type {number}\n       */\n      this.twist = 0;\n\n      /**\n       * Barrel pressure on a stylus pointer.\n       * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n       * @type {number}\n       */\n      this.tangentialPressure = 0;\n    }\n\n    /**\n     * The unique identifier of the pointer. It will be the same as `identifier`.\n     * @readonly\n     * @member {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n     */\n\n    createClass(InteractionData, [{\n      key: '_copyEvent',\n      /**\n       * Copies properties from normalized event data.\n       *\n       * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n       * @private\n       */\n      value: function _copyEvent(event) {\n        // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n        // it with \"false\" on later events when our shim for it on touch events might not be\n        // accurate\n        if (event.isPrimary) {\n          this.isPrimary = true;\n        }\n        this.button = event.button;\n        this.buttons = event.buttons;\n        this.width = event.width;\n        this.height = event.height;\n        this.tiltX = event.tiltX;\n        this.tiltY = event.tiltY;\n        this.pointerType = event.pointerType;\n        this.pressure = event.pressure;\n        this.rotationAngle = event.rotationAngle;\n        this.twist = event.twist || 0;\n        this.tangentialPressure = event.tangentialPressure || 0;\n      }\n\n      /**\n       * Resets the data for pooling.\n       *\n       * @private\n       */\n    }, {\n      key: '_reset',\n      value: function _reset() {\n        // isPrimary is the only property that we really need to reset - everything else is\n        // guaranteed to be overwritten\n        this.isPrimary = false;\n      }\n    }, {\n      key: 'pointerId',\n      get: function get$$1() {\n        return this.identifier;\n      }\n    }]);\n    return InteractionData;\n  }();\n\n  /**\n   * Event class that mimics native DOM events.\n   *\n   * @class\n   */\n  var InteractionEvent = function () {\n    /**\n     * InteractionEvent constructor\n     */\n    function InteractionEvent() {\n      classCallCheck(this, InteractionEvent);\n\n      /**\n       * Whether this event will continue propagating in the tree\n       *\n       * @member {boolean}\n       */\n      this.stopped = false;\n\n      /**\n       * The object which caused this event to be dispatched.\n       *\n       * @member {Object3D}\n       */\n      this.target = null;\n\n      /**\n       * The object whose event listener’s callback is currently being invoked.\n       *\n       * @member {Object3D}\n       */\n      this.currentTarget = null;\n\n      /**\n       * Type of the event\n       *\n       * @member {string}\n       */\n      this.type = null;\n\n      /**\n       * InteractionData related to this event\n       *\n       * @member {InteractionData}\n       */\n      this.data = null;\n\n      /**\n       * ray caster detial from 3d-mesh\n       *\n       * @member {Intersects}\n       */\n      this.intersects = [];\n    }\n\n    /**\n     * Prevents event from reaching any objects other than the current object.\n     *\n     */\n\n    createClass(InteractionEvent, [{\n      key: \"stopPropagation\",\n      value: function stopPropagation() {\n        this.stopped = true;\n      }\n\n      /**\n       * Resets the event.\n       *\n       * @private\n       */\n    }, {\n      key: \"_reset\",\n      value: function _reset() {\n        this.stopped = false;\n        this.currentTarget = null;\n        this.target = null;\n        this.intersects = [];\n      }\n    }]);\n    return InteractionEvent;\n  }();\n\n  /**\n   * DisplayObjects with the `trackedPointers` property use this class to track interactions\n   *\n   * @class\n   * @private\n   */\n  var InteractionTrackingData = function () {\n    /**\n     * @param {number} pointerId - Unique pointer id of the event\n     */\n    function InteractionTrackingData(pointerId) {\n      classCallCheck(this, InteractionTrackingData);\n      this._pointerId = pointerId;\n      this._flags = InteractionTrackingData.FLAGS.NONE;\n    }\n\n    /**\n     *\n     * @private\n     * @param {number} flag - The interaction flag to set\n     * @param {boolean} yn - Should the flag be set or unset\n     */\n\n    createClass(InteractionTrackingData, [{\n      key: \"_doSet\",\n      value: function _doSet(flag, yn) {\n        if (yn) {\n          this._flags = this._flags | flag;\n        } else {\n          this._flags = this._flags & ~flag;\n        }\n      }\n\n      /**\n       * Unique pointer id of the event\n       *\n       * @readonly\n       * @member {number}\n       */\n    }, {\n      key: \"pointerId\",\n      get: function get$$1() {\n        return this._pointerId;\n      }\n\n      /**\n       * State of the tracking data, expressed as bit flags\n       *\n       * @member {number}\n       */\n    }, {\n      key: \"flags\",\n      get: function get$$1() {\n        return this._flags;\n      }\n\n      /**\n       * Set the flags for the tracking data\n       *\n       * @param {number} flags - Flags to set\n       */,\n\n      set: function set$$1(flags) {\n        this._flags = flags;\n      }\n\n      /**\n       * Is the tracked event inactive (not over or down)?\n       *\n       * @member {number}\n       */\n    }, {\n      key: \"none\",\n      get: function get$$1() {\n        return this._flags === this.constructor.FLAGS.NONE;\n      }\n\n      /**\n       * Is the tracked event over the DisplayObject?\n       *\n       * @member {boolean}\n       */\n    }, {\n      key: \"over\",\n      get: function get$$1() {\n        return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n      }\n\n      /**\n       * Set the over flag\n       *\n       * @param {boolean} yn - Is the event over?\n       */,\n\n      set: function set$$1(yn) {\n        this._doSet(this.constructor.FLAGS.OVER, yn);\n      }\n\n      /**\n       * Did the right mouse button come down in the DisplayObject?\n       *\n       * @member {boolean}\n       */\n    }, {\n      key: \"rightDown\",\n      get: function get$$1() {\n        return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n      }\n\n      /**\n       * Set the right down flag\n       *\n       * @param {boolean} yn - Is the right mouse button down?\n       */,\n\n      set: function set$$1(yn) {\n        this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n      }\n\n      /**\n       * Did the left mouse button come down in the DisplayObject?\n       *\n       * @member {boolean}\n       */\n    }, {\n      key: \"leftDown\",\n      get: function get$$1() {\n        return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n      }\n\n      /**\n       * Set the left down flag\n       *\n       * @param {boolean} yn - Is the left mouse button down?\n       */,\n\n      set: function set$$1(yn) {\n        this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n      }\n    }]);\n    return InteractionTrackingData;\n  }();\n  InteractionTrackingData.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  });\n  var MOUSE_POINTER_ID = 'MOUSE';\n\n  // helpers for hitTest() - only used inside hitTest()\n  var hitTestEvent = {\n    target: null,\n    data: {\n      global: null\n    }\n  };\n\n  /**\n   * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n   * if its interactive parameter is set to true\n   * This manager also supports multitouch.\n   *\n   * reference to [pixi.js](http://www.pixijs.com/) impl\n   *\n   * @private\n   * @class\n   * @extends EventDispatcher\n   */\n\n  var InteractionManager = function (_EventDispatcher) {\n    inherits(InteractionManager, _EventDispatcher);\n\n    /**\n     * @param {WebGLRenderer} renderer - A reference to the current renderer\n     * @param {Scene} scene - A reference to the current scene\n     * @param {Camera} camera - A reference to the current camera\n     * @param {Object} [options] - The options for the manager.\n     * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n     * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n     * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n     */\n    function InteractionManager(renderer, scene, camera, options) {\n      classCallCheck(this, InteractionManager);\n      var _this = possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));\n      options = options || {};\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {WebGLRenderer}\n       */\n      _this.renderer = renderer;\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {Scene}\n       */\n      _this.scene = scene;\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {Camera}\n       */\n      _this.camera = camera;\n\n      /**\n       * Should default browser actions automatically be prevented.\n       * Does not apply to pointer events for backwards compatibility\n       * preventDefault on pointer events stops mouse events from firing\n       * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n       *\n       * @member {boolean}\n       * @default false\n       */\n      _this.autoPreventDefault = options.autoPreventDefault || false;\n\n      /**\n       * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n       *\n       * @member {number}\n       * @default 10\n       */\n      _this.interactionFrequency = options.interactionFrequency || 10;\n\n      /**\n       * The mouse data\n       *\n       * @member {InteractionData}\n       */\n      _this.mouse = new InteractionData();\n      _this.mouse.identifier = MOUSE_POINTER_ID;\n\n      // setting the mouse to start off far off screen will mean that mouse over does\n      //  not get called before we even move the mouse.\n      _this.mouse.global.set(-999999);\n\n      /**\n       * Actively tracked InteractionData\n       *\n       * @private\n       * @member {Object.<number,InteractionData>}\n       */\n      _this.activeInteractionData = {};\n      _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n\n      /**\n       * Pool of unused InteractionData\n       *\n       * @private\n       * @member {InteractionData[]}\n       */\n      _this.interactionDataPool = [];\n\n      /**\n       * An event data object to handle all the event tracking/dispatching\n       *\n       * @member {object}\n       */\n      _this.eventData = new InteractionEvent();\n\n      /**\n       * The DOM element to bind to.\n       *\n       * @private\n       * @member {HTMLElement}\n       */\n      _this.interactionDOMElement = null;\n\n      /**\n       * This property determines if mousemove and touchmove events are fired only when the cursor\n       * is over the object.\n       * Setting to true will make things work more in line with how the DOM verison works.\n       * Setting to false can make things easier for things like dragging\n       * It is currently set to false as this is how three.js used to work.\n       *\n       * @member {boolean}\n       * @default true\n       */\n      _this.moveWhenInside = true;\n\n      /**\n       * Have events been attached to the dom element?\n       *\n       * @private\n       * @member {boolean}\n       */\n      _this.eventsAdded = false;\n\n      /**\n       * Is the mouse hovering over the renderer?\n       *\n       * @private\n       * @member {boolean}\n       */\n      _this.mouseOverRenderer = false;\n\n      /**\n       * Does the device support touch events\n       * https://www.w3.org/TR/touch-events/\n       *\n       * @readonly\n       * @member {boolean}\n       */\n      _this.supportsTouchEvents = 'ontouchstart' in window;\n\n      /**\n       * Does the device support pointer events\n       * https://www.w3.org/Submission/pointer-events/\n       *\n       * @readonly\n       * @member {boolean}\n       */\n      _this.supportsPointerEvents = !!window.PointerEvent;\n\n      // this will make it so that you don't have to call bind all the time\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onClick = _this.onClick.bind(_this);\n      _this.processClick = _this.processClick.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerUp = _this.onPointerUp.bind(_this);\n      _this.processPointerUp = _this.processPointerUp.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n      _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerDown = _this.onPointerDown.bind(_this);\n      _this.processPointerDown = _this.processPointerDown.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerMove = _this.onPointerMove.bind(_this);\n      _this.processPointerMove = _this.processPointerMove.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerOut = _this.onPointerOut.bind(_this);\n      _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerOver = _this.onPointerOver.bind(_this);\n\n      /**\n       * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n       * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n       * and functions are called instead of changing the CSS.\n       * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n       * @member {Object.<string, (string|Function|Object.<string, string>)>}\n       */\n      _this.cursorStyles = {\n        default: 'inherit',\n        pointer: 'pointer'\n      };\n\n      /**\n       * The mode of the cursor that is being used.\n       * The value of this is a key from the cursorStyles dictionary.\n       *\n       * @member {string}\n       */\n      _this.currentCursorMode = null;\n\n      /**\n       * Internal cached let.\n       *\n       * @private\n       * @member {string}\n       */\n      _this.cursor = null;\n\n      /**\n       * ray caster, for survey intersects from 3d-scene\n       *\n       * @private\n       * @member {Raycaster}\n       */\n      _this.raycaster = new three.Raycaster();\n\n      /**\n       * snippet time\n       *\n       * @private\n       * @member {Number}\n       */\n      _this._deltaTime = 0;\n      _this.setTargetElement(_this.renderer.domElement);\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n       * object.\n       *\n       * @event InteractionManager#mousedown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * on the display object.\n       *\n       * @event InteractionManager#rightdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released over the display\n       * object.\n       *\n       * @event InteractionManager#mouseup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * over the display object.\n       *\n       * @event InteractionManager#rightup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n       * the display object.\n       *\n       * @event InteractionManager#click\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * and released on the display object.\n       *\n       * @event InteractionManager#rightclick\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released outside the\n       * display object that initially registered a\n       * [mousedown]{@link InteractionManager#event:mousedown}.\n       *\n       * @event InteractionManager#mouseupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * outside the display object that initially registered a\n       * [rightdown]{@link InteractionManager#event:rightdown}.\n       *\n       * @event InteractionManager#rightupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved while over the display object\n       *\n       * @event InteractionManager#mousemove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved onto the display object\n       *\n       * @event InteractionManager#mouseover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved off the display object\n       *\n       * @event InteractionManager#mouseout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed on the display object.\n       *\n       * @event InteractionManager#pointerdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released over the display object.\n       *\n       * @event InteractionManager#pointerup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a pointer event\n       *\n       * @event InteractionManager#pointercancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed and released on the display object.\n       *\n       * @event InteractionManager#pointertap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released outside the display object that initially\n       * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n       *\n       * @event InteractionManager#pointerupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved while over the display object\n       *\n       * @event InteractionManager#pointermove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved onto the display object\n       *\n       * @event InteractionManager#pointerover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved off the display object\n       *\n       * @event InteractionManager#pointerout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed on the display object.\n       *\n       * @event InteractionManager#touchstart\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed from the display object.\n       *\n       * @event InteractionManager#touchend\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a touch\n       *\n       * @event InteractionManager#touchcancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed and removed from the display object.\n       *\n       * @event InteractionManager#tap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed outside of the display object that initially\n       * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n       *\n       * @event InteractionManager#touchendoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is moved along the display object.\n       *\n       * @event InteractionManager#touchmove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n       * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mousedown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released over the display\n       * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n       * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#click\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightclick\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released outside the\n       * display object that initially registered a\n       * [mousedown]{@link Object3D#event:mousedown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * outside the display object that initially registered a\n       * [rightdown]{@link Object3D#event:rightdown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved while over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mousemove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved onto the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved off the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a pointer event.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointercancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed and released on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointertap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released outside the display object that initially\n       * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved while over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointermove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved onto the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved off the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchstart\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed from the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchend\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a touch.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchcancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed and removed from the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#tap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed outside of the display object that initially\n       * registered a [touchstart]{@link Object3D#event:touchstart}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchendoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is moved along the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchmove\n       * @param {InteractionEvent} event - Interaction event\n       */\n      return _this;\n    }\n\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param {Point} globalPoint - A point to hit test with, in global space.\n     * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return {Object3D} The hit display object, if any.\n     */\n\n    createClass(InteractionManager, [{\n      key: 'hitTest',\n      value: function hitTest(globalPoint, root) {\n        // clear the target for our hit test\n        hitTestEvent.target = null;\n        // assign the global point\n        hitTestEvent.data.global = globalPoint;\n        // ensure safety of the root\n        if (!root) {\n          root = this.scene;\n        }\n        // run the hit test\n        this.processInteractive(hitTestEvent, root, null, true);\n        // return our found object - it'll be null if we didn't hit anything\n\n        return hitTestEvent.target;\n      }\n\n      /**\n       * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n       * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n       * another DOM element to receive those events.\n       *\n       * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n       */\n    }, {\n      key: 'setTargetElement',\n      value: function setTargetElement(element) {\n        this.removeEvents();\n        this.interactionDOMElement = element;\n        this.addEvents();\n      }\n\n      /**\n       * Registers all the DOM events\n       *\n       * @private\n       */\n    }, {\n      key: 'addEvents',\n      value: function addEvents() {\n        if (!this.interactionDOMElement || this.eventsAdded) {\n          return;\n        }\n        this.emit('addevents');\n        this.interactionDOMElement.addEventListener('click', this.onClick, true);\n        if (window.navigator.msPointerEnabled) {\n          this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n          this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n        } else if (this.supportsPointerEvents) {\n          this.interactionDOMElement.style['touch-action'] = 'none';\n        }\n\n        /**\n         * These events are added first, so that if pointer events are normalised, they are fired\n         * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents) {\n          window.document.addEventListener('pointermove', this.onPointerMove, true);\n          this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n          // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n          // we already handle those, so for the purposes of what we do in onPointerOut, we only\n          // care about the pointerleave event\n          this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n          this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n          window.addEventListener('pointercancel', this.onPointerCancel, true);\n          window.addEventListener('pointerup', this.onPointerUp, true);\n        } else {\n          window.document.addEventListener('mousemove', this.onPointerMove, true);\n          this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n          this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n          this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n          window.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents) {\n          this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n          this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n          this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n          this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n        this.eventsAdded = true;\n      }\n\n      /**\n       * Removes all the DOM events that were previously registered\n       *\n       * @private\n       */\n    }, {\n      key: 'removeEvents',\n      value: function removeEvents() {\n        if (!this.interactionDOMElement) {\n          return;\n        }\n        this.emit('removeevents');\n        this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n        if (window.navigator.msPointerEnabled) {\n          this.interactionDOMElement.style['-ms-content-zooming'] = '';\n          this.interactionDOMElement.style['-ms-touch-action'] = '';\n        } else if (this.supportsPointerEvents) {\n          this.interactionDOMElement.style['touch-action'] = '';\n        }\n        if (this.supportsPointerEvents) {\n          window.document.removeEventListener('pointermove', this.onPointerMove, true);\n          this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n          this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n          window.removeEventListener('pointercancel', this.onPointerCancel, true);\n          window.removeEventListener('pointerup', this.onPointerUp, true);\n        } else {\n          window.document.removeEventListener('mousemove', this.onPointerMove, true);\n          this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n          this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n          window.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n        if (this.supportsTouchEvents) {\n          this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n          this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n          this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n        this.interactionDOMElement = null;\n        this.eventsAdded = false;\n      }\n\n      /**\n       * Updates the state of interactive objects.\n       * Invoked by a throttled ticker.\n       *\n       * @param {number} deltaTime - time delta since last tick\n       */\n    }, {\n      key: 'update',\n      value: function update(_ref) {\n        var snippet = _ref.snippet;\n        this._deltaTime += snippet;\n        if (this._deltaTime < this.interactionFrequency) {\n          return;\n        }\n        this._deltaTime = 0;\n        if (!this.interactionDOMElement) {\n          return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this.didMove) {\n          this.didMove = false;\n          return;\n        }\n        this.cursor = null;\n\n        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n        // but there was a scenario of a display object moving under a static mouse cursor.\n        // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n        for (var k in this.activeInteractionData) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (this.activeInteractionData.hasOwnProperty(k)) {\n            var interactionData = this.activeInteractionData[k];\n            if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n              var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n              this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);\n            }\n          }\n        }\n        this.setCursorMode(this.cursor);\n\n        // TODO\n      }\n\n      /**\n       * Sets the current cursor mode, handling any callbacks or CSS style changes.\n       *\n       * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n       */\n    }, {\n      key: 'setCursorMode',\n      value: function setCursorMode(mode) {\n        mode = mode || 'default';\n        // if the mode didn't actually change, bail early\n        if (this.currentCursorMode === mode) {\n          return;\n        }\n        this.currentCursorMode = mode;\n        var style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style) {\n          switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n            case 'string':\n              // string styles are handled as cursor CSS\n              this.interactionDOMElement.style.cursor = style;\n              break;\n            case 'function':\n              // functions are just called, and passed the cursor mode\n              style(mode);\n              break;\n            case 'object':\n              // if it is an object, assume that it is a dictionary of CSS styles,\n              // apply it to the interactionDOMElement\n              Object.assign(this.interactionDOMElement.style, style);\n              break;\n            default:\n              break;\n          }\n        } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n          // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n          // for the mode, then assume that the dev wants it to be CSS for the cursor.\n          this.interactionDOMElement.style.cursor = mode;\n        }\n      }\n\n      /**\n       * Dispatches an event on the display object that was interacted with\n       *\n       * @param {Object3D} displayObject - the display object in question\n       * @param {string} eventString - the name of the event (e.g, mousedown)\n       * @param {object} eventData - the event data object\n       * @private\n       */\n    }, {\n      key: 'triggerEvent',\n      value: function triggerEvent(displayObject, eventString, eventData) {\n        if (!eventData.stopped) {\n          eventData.currentTarget = displayObject;\n          eventData.type = eventString;\n          displayObject.emit(eventString, eventData);\n          if (displayObject[eventString]) {\n            displayObject[eventString](eventData);\n          }\n        }\n      }\n\n      /**\n       * This function is provides a neat way of crawling through the scene graph and running a\n       * specified function on all interactive objects it finds. It will also take care of hit\n       * testing the interactive objects and passes the hit across in the function.\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - event containing the point that\n       *  is tested for collision\n       * @param {Object3D} displayObject - the displayObject\n       *  that will be hit test (recursively crawls its children)\n       * @param {Function} [func] - the function that will be called on each interactive object. The\n       *  interactionEvent, displayObject and hit will be passed to the function\n       * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n       * @param {boolean} [interactive] - Whether the displayObject is interactive\n       * @return {boolean} returns true if the displayObject hit the point\n       */\n    }, {\n      key: 'processInteractive',\n      value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n        if (!displayObject || !displayObject.visible) {\n          return false;\n        }\n\n        // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n        //\n        // This function will now loop through all objects and then only hit test the objects it HAS\n        // to, not all of them. MUCH faster..\n        // An object will be hit test if the following is true:\n        //\n        // 1: It is interactive.\n        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n        //\n        // As another little optimisation once an interactive object has been hit we can carry on\n        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n        // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n        interactive = displayObject.interactive || interactive;\n        var hit = false;\n        var interactiveParent = interactive;\n        if (displayObject.interactiveChildren && displayObject.children) {\n          var children = displayObject.children;\n          for (var i = children.length - 1; i >= 0; i--) {\n            var child = children[i];\n\n            // time to get recursive.. if this function will return if something is hit..\n            var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n            if (childHit) {\n              // its a good idea to check if a child has lost its parent.\n              // this means it has been removed whilst looping so its best\n              if (!child.parent) {\n                continue;\n              }\n\n              // we no longer need to hit test any more objects in this container as we we\n              // now know the parent has been hit\n              interactiveParent = false;\n\n              // If the child is interactive , that means that the object hit was actually\n              // interactive and not just the child of an interactive object.\n              // This means we no longer need to hit test anything else. We still need to run\n              // through all objects, but we don't need to perform any hit tests.\n\n              if (childHit) {\n                if (interactionEvent.target) {\n                  hitTest = false;\n                }\n                hit = true;\n              }\n            }\n          }\n        }\n\n        // no point running this if the item is not interactive or does not have an interactive parent.\n        if (interactive) {\n          // if we are hit testing (as in we have no hit any objects yet)\n          // We also don't need to worry about hit testing if once of the displayObjects children\n          // has already been hit - but only if it was interactive, otherwise we need to keep\n          // looking for an interactive child, just in case we hit one\n          if (hitTest && !interactionEvent.target) {\n            if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n              hit = true;\n            }\n          }\n          if (displayObject.interactive) {\n            if (hit && !interactionEvent.target) {\n              interactionEvent.data.target = interactionEvent.target = displayObject;\n            }\n            if (func) {\n              func(interactionEvent, displayObject, !!hit);\n            }\n          }\n        }\n        return hit;\n      }\n\n      /**\n       * Is called when the click is pressed down on the renderer element\n       *\n       * @private\n       * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n       */\n    }, {\n      key: 'onClick',\n      value: function onClick(originalEvent) {\n        if (originalEvent.type !== 'click') return;\n        var events = this.normalizeToPointerData(originalEvent);\n        if (this.autoPreventDefault && events[0].isNormalized) {\n          originalEvent.preventDefault();\n        }\n        var interactionData = this.getInteractionDataForPointerId(events[0]);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n        this.emit('click', interactionEvent);\n      }\n\n      /**\n       * Processes the result of the click check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processClick',\n      value: function processClick(interactionEvent, displayObject, hit) {\n        if (hit) {\n          this.triggerEvent(displayObject, 'click', interactionEvent);\n        }\n      }\n\n      /**\n       * Is called when the pointer button is pressed down on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n       */\n    }, {\n      key: 'onPointerDown',\n      value: function onPointerDown(originalEvent) {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n\n        /**\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && events[0].isNormalized) {\n          originalEvent.preventDefault();\n        }\n        var eventLen = events.length;\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n          this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n          this.emit('pointerdown', interactionEvent);\n          if (event.pointerType === 'touch') {\n            this.emit('touchstart', interactionEvent);\n          } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n            var isRightButton = event.button === 2;\n            this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n          }\n        }\n      }\n\n      /**\n       * Processes the result of the pointer down check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerDown',\n      value: function processPointerDown(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        if (hit) {\n          if (!displayObject.trackedPointers[id]) {\n            displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n          }\n          this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n          if (data.pointerType === 'touch') {\n            displayObject.started = true;\n            this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n          } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n            var isRightButton = data.button === 2;\n            if (isRightButton) {\n              displayObject.trackedPointers[id].rightDown = true;\n            } else {\n              displayObject.trackedPointers[id].leftDown = true;\n            }\n            this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is released on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n       * @param {boolean} cancelled - true if the pointer is cancelled\n       * @param {Function} func - Function passed to {@link processInteractive}\n       */\n    }, {\n      key: 'onPointerComplete',\n      value: function onPointerComplete(originalEvent, cancelled, func) {\n        var events = this.normalizeToPointerData(originalEvent);\n        var eventLen = events.length;\n\n        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n        // in all cases (unless it was a pointercancel)\n        var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n\n          // perform hit testing for events targeting our canvas or cancel events\n          this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n          this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n          if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n            var isRightButton = event.button === 2;\n            this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n          } else if (event.pointerType === 'touch') {\n            this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n            this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is cancelled\n       *\n       * @private\n       * @param {PointerEvent} event - The DOM event of a pointer button being released\n       */\n    }, {\n      key: 'onPointerCancel',\n      value: function onPointerCancel(event) {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n        this.onPointerComplete(event, true, this.processPointerCancel);\n      }\n\n      /**\n       * Processes the result of the pointer cancel check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       */\n    }, {\n      key: 'processPointerCancel',\n      value: function processPointerCancel(interactionEvent, displayObject) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        if (displayObject.trackedPointers[id] !== undefined) {\n          delete displayObject.trackedPointers[id];\n          this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n          if (data.pointerType === 'touch') {\n            this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is released on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} event - The DOM event of a pointer button being released\n       */\n    }, {\n      key: 'onPointerUp',\n      value: function onPointerUp(event) {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n        this.onPointerComplete(event, false, this.processPointerUp);\n      }\n\n      /**\n       * Processes the result of the pointer up check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerUp',\n      value: function processPointerUp(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        var trackingData = displayObject.trackedPointers[id];\n        var isTouch = data.pointerType === 'touch';\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n        // Mouse only\n        if (isMouse) {\n          var isRightButton = data.button === 2;\n          var flags = InteractionTrackingData.FLAGS;\n          var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n          var isDown = trackingData !== undefined && trackingData.flags & test;\n          if (hit) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n            if (isDown) {\n              this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n            }\n          } else if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n          }\n          // update the down state of the tracking data\n          if (trackingData) {\n            if (isRightButton) {\n              trackingData.rightDown = false;\n            } else {\n              trackingData.leftDown = false;\n            }\n          }\n        }\n\n        // Pointers and Touches, and Mouse\n        if (isTouch && displayObject.started) {\n          displayObject.started = false;\n          this.triggerEvent(displayObject, 'touchend', interactionEvent);\n        }\n        if (hit) {\n          this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n          if (trackingData) {\n            this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n            if (isTouch) {\n              this.triggerEvent(displayObject, 'tap', interactionEvent);\n              // touches are no longer over (if they ever were) when we get the touchend\n              // so we should ensure that we don't keep pretending that they are\n              trackingData.over = false;\n            }\n          }\n        } else if (trackingData) {\n          this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n          if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n        }\n        // Only remove the tracking data if there is no over/down state still associated with it\n        if (trackingData && trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n\n      /**\n       * Is called when the pointer moves across the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n       */\n    }, {\n      key: 'onPointerMove',\n      value: function onPointerMove(originalEvent) {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n        if (events[0].pointerType === 'mouse') {\n          this.didMove = true;\n          this.cursor = null;\n        }\n        var eventLen = events.length;\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n          var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n          this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);\n          this.emit('pointermove', interactionEvent);\n          if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n          if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n        }\n        if (events[0].pointerType === 'mouse') {\n          this.setCursorMode(this.cursor);\n\n          // TODO BUG for parents interactive object (border order issue)\n        }\n      }\n\n      /**\n       * Processes the result of the pointer move check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerMove',\n      value: function processPointerMove(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var isTouch = data.pointerType === 'touch';\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n        if (isMouse) {\n          this.processPointerOverOut(interactionEvent, displayObject, hit);\n        }\n        if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n        if (!this.moveWhenInside || hit) {\n          this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n          if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n        }\n      }\n\n      /**\n       * Is called when the pointer is moved out of the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n       */\n    }, {\n      key: 'onPointerOut',\n      value: function onPointerOut(originalEvent) {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOut, so events will always be length 1\n        var event = events[0];\n        if (event.pointerType === 'mouse') {\n          this.mouseOverRenderer = false;\n          this.setCursorMode(null);\n        }\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = event;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n        this.emit('pointerout', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          this.emit('mouseout', interactionEvent);\n        } else {\n          // we can get touchleave events after touchend, so we want to make sure we don't\n          // introduce memory leaks\n          this.releaseInteractionDataForPointerId(interactionData.identifier);\n        }\n      }\n\n      /**\n       * Processes the result of the pointer over/out check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerOverOut',\n      value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n        var trackingData = displayObject.trackedPointers[id];\n\n        // if we just moused over the display object, then we need to track that state\n        if (hit && !trackingData) {\n          trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n        if (trackingData === undefined) return;\n        if (hit && this.mouseOverRenderer) {\n          if (!trackingData.over) {\n            trackingData.over = true;\n            this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n            if (isMouse) {\n              this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n            }\n          }\n\n          // only change the cursor if it has not already been changed (by something deeper in the\n          // display tree)\n          if (isMouse && this.cursor === null) {\n            this.cursor = displayObject.cursor;\n          }\n        } else if (trackingData.over) {\n          trackingData.over = false;\n          this.triggerEvent(displayObject, 'pointerout', this.eventData);\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n          }\n          // if there is no mouse down information for the pointer, then it is safe to delete\n          if (trackingData.none) {\n            delete displayObject.trackedPointers[id];\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer is moved into the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n       */\n    }, {\n      key: 'onPointerOver',\n      value: function onPointerOver(originalEvent) {\n        var events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOver, so events will always be length 1\n        var event = events[0];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = event;\n        if (event.pointerType === 'mouse') {\n          this.mouseOverRenderer = true;\n        }\n        this.emit('pointerover', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          this.emit('mouseover', interactionEvent);\n        }\n      }\n\n      /**\n       * Get InteractionData for a given pointerId. Store that data as well\n       *\n       * @private\n       * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n       * @return {InteractionData} - Interaction data for the given pointer identifier\n       */\n    }, {\n      key: 'getInteractionDataForPointerId',\n      value: function getInteractionDataForPointerId(event) {\n        var pointerId = event.pointerId;\n        var interactionData = void 0;\n        if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n          interactionData = this.mouse;\n        } else if (this.activeInteractionData[pointerId]) {\n          interactionData = this.activeInteractionData[pointerId];\n        } else {\n          interactionData = this.interactionDataPool.pop() || new InteractionData();\n          interactionData.identifier = pointerId;\n          this.activeInteractionData[pointerId] = interactionData;\n        }\n        // copy properties from the event, so that we can make sure that touch/pointer specific\n        // data is available\n        interactionData._copyEvent(event);\n        return interactionData;\n      }\n\n      /**\n       * Return unused InteractionData to the pool, for a given pointerId\n       *\n       * @private\n       * @param {number} pointerId - Identifier from a pointer event\n       */\n    }, {\n      key: 'releaseInteractionDataForPointerId',\n      value: function releaseInteractionDataForPointerId(pointerId) {\n        var interactionData = this.activeInteractionData[pointerId];\n        if (interactionData) {\n          delete this.activeInteractionData[pointerId];\n          interactionData._reset();\n          this.interactionDataPool.push(interactionData);\n        }\n      }\n\n      /**\n       * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n       * resulting value is stored in the point. This takes into account the fact that the DOM\n       * element could be scaled and positioned anywhere on the screen.\n       *\n       * @param  {Vector2} point - the point that the result will be stored in\n       * @param  {number} x - the x coord of the position to map\n       * @param  {number} y - the y coord of the position to map\n       */\n    }, {\n      key: 'mapPositionToPoint',\n      value: function mapPositionToPoint(point, x, y) {\n        var rect = void 0;\n\n        // IE 11 fix\n        if (!this.interactionDOMElement.parentElement) {\n          rect = {\n            x: 0,\n            y: 0,\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n          };\n        } else {\n          rect = this.interactionDOMElement.getBoundingClientRect();\n        }\n        point.x = (x - rect.left) / rect.width * 2 - 1;\n        point.y = -((y - rect.top) / rect.height) * 2 + 1;\n      }\n\n      /**\n       * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The event to be configured\n       * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n       * @param {InteractionData} interactionData - The InteractionData that will be paired\n       *        with the InteractionEvent\n       * @return {InteractionEvent} the interaction event that was passed in\n       */\n    }, {\n      key: 'configureInteractionEventForDOMEvent',\n      value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n        interactionEvent.data = interactionData;\n        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n        this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n        // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n        if (pointerEvent.pointerType === 'touch') {\n          pointerEvent.globalX = interactionData.global.x;\n          pointerEvent.globalY = interactionData.global.y;\n        }\n        interactionData.originalEvent = pointerEvent;\n        interactionEvent._reset();\n        interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n        return interactionEvent;\n      }\n\n      /**\n       * Ensures that the original event object contains all data that a regular pointer event would have\n       *\n       * @private\n       * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n       * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n       */\n    }, {\n      key: 'normalizeToPointerData',\n      value: function normalizeToPointerData(event) {\n        var normalizedEvents = [];\n        if (this.supportsTouchEvents && event instanceof TouchEvent) {\n          for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n            var touch = event.changedTouches[i];\n            if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n            if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n            if (typeof touch.isPrimary === 'undefined') {\n              touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n            }\n            if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n            if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n            if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n            if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n            if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n            if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n            if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n            touch.twist = 0;\n            touch.tangentialPressure = 0;\n            // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n            // support, and the fill ins are not quite the same\n            // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n            // left is not 0,0 on the page\n            if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n            if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n            // mark the touch as normalized, just so that we know we did it\n            touch.isNormalized = true;\n            normalizedEvents.push(touch);\n          }\n        } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n          if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n          if (typeof event.width === 'undefined') event.width = 1;\n          if (typeof event.height === 'undefined') event.height = 1;\n          if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n          if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n          if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n          if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n          if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n          event.twist = 0;\n          event.tangentialPressure = 0;\n\n          // mark the mouse event as normalized, just so that we know we did it\n          event.isNormalized = true;\n          normalizedEvents.push(event);\n        } else {\n          normalizedEvents.push(event);\n        }\n        return normalizedEvents;\n      }\n\n      /**\n       * Destroys the interaction manager\n       *\n       */\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeEvents();\n        this.removeAllListeners();\n        this.renderer = null;\n        this.mouse = null;\n        this.eventData = null;\n        this.interactionDOMElement = null;\n        this.onPointerDown = null;\n        this.processPointerDown = null;\n        this.onPointerUp = null;\n        this.processPointerUp = null;\n        this.onPointerCancel = null;\n        this.processPointerCancel = null;\n        this.onPointerMove = null;\n        this.processPointerMove = null;\n        this.onPointerOut = null;\n        this.processPointerOverOut = null;\n        this.onPointerOver = null;\n        this._tempPoint = null;\n      }\n    }]);\n    return InteractionManager;\n  }(three.EventDispatcher);\n  var MOUSE_POINTER_ID$1 = 'MOUSE';\n\n  // helpers for hitTest() - only used inside hitTest()\n  var hitTestEvent$1 = {\n    target: null,\n    data: {\n      global: null\n    }\n  };\n\n  /**\n   * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n   * if its interactive parameter is set to true\n   * This manager also supports multitouch.\n   *\n   * reference to [pixi.js](http://www.pixijs.com/) impl\n   *\n   * @private\n   * @class\n   * @extends EventDispatcher\n   */\n\n  var InteractionLayer = function (_EventDispatcher) {\n    inherits(InteractionLayer, _EventDispatcher);\n\n    /**\n     * @param {WebGLRenderer} renderer - A reference to the current renderer\n     * @param {Object} [options] - The options for the manager.\n     * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n     * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n     * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n     */\n    function InteractionLayer(renderer, options) {\n      classCallCheck(this, InteractionLayer);\n      var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this));\n      options = options || {};\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {WebGLRenderer}\n       */\n      _this.renderer = renderer;\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {Layer}\n       */\n      _this.layer = null;\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {Scene}\n       */\n      // this.scene = scene;\n\n      /**\n       * The renderer this interaction manager works for.\n       *\n       * @member {Camera}\n       */\n      // this.camera = camera;\n\n      /**\n       * Should default browser actions automatically be prevented.\n       * Does not apply to pointer events for backwards compatibility\n       * preventDefault on pointer events stops mouse events from firing\n       * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n       *\n       * @member {boolean}\n       * @default false\n       */\n      _this.autoPreventDefault = options.autoPreventDefault || false;\n\n      /**\n       * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n       *\n       * @member {number}\n       * @default 10\n       */\n      _this.interactionFrequency = options.interactionFrequency || 10;\n\n      /**\n       * The mouse data\n       *\n       * @member {InteractionData}\n       */\n      _this.mouse = new InteractionData();\n      _this.mouse.identifier = MOUSE_POINTER_ID$1;\n\n      // setting the mouse to start off far off screen will mean that mouse over does\n      //  not get called before we even move the mouse.\n      _this.mouse.global.set(-999999);\n\n      /**\n       * Actively tracked InteractionData\n       *\n       * @private\n       * @member {Object.<number,InteractionData>}\n       */\n      _this.activeInteractionData = {};\n      _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;\n\n      /**\n       * Pool of unused InteractionData\n       *\n       * @private\n       * @member {InteractionData[]}\n       */\n      _this.interactionDataPool = [];\n\n      /**\n       * An event data object to handle all the event tracking/dispatching\n       *\n       * @member {object}\n       */\n      _this.eventData = new InteractionEvent();\n\n      /**\n       * The DOM element to bind to.\n       *\n       * @private\n       * @member {HTMLElement}\n       */\n      _this.interactionDOMElement = null;\n\n      /**\n       * This property determines if mousemove and touchmove events are fired only when the cursor\n       * is over the object.\n       * Setting to true will make things work more in line with how the DOM verison works.\n       * Setting to false can make things easier for things like dragging\n       * It is currently set to false as this is how three.js used to work.\n       *\n       * @member {boolean}\n       * @default true\n       */\n      _this.moveWhenInside = true;\n\n      /**\n       * Have events been attached to the dom element?\n       *\n       * @private\n       * @member {boolean}\n       */\n      _this.eventsAdded = false;\n\n      /**\n       * Is the mouse hovering over the renderer?\n       *\n       * @private\n       * @member {boolean}\n       */\n      _this.mouseOverRenderer = false;\n\n      /**\n       * Does the device support touch events\n       * https://www.w3.org/TR/touch-events/\n       *\n       * @readonly\n       * @member {boolean}\n       */\n      _this.supportsTouchEvents = 'ontouchstart' in window;\n\n      /**\n       * Does the device support pointer events\n       * https://www.w3.org/Submission/pointer-events/\n       *\n       * @readonly\n       * @member {boolean}\n       */\n      _this.supportsPointerEvents = !!window.PointerEvent;\n\n      // this will make it so that you don't have to call bind all the time\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onClick = _this.onClick.bind(_this);\n      _this.processClick = _this.processClick.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerUp = _this.onPointerUp.bind(_this);\n      _this.processPointerUp = _this.processPointerUp.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n      _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerDown = _this.onPointerDown.bind(_this);\n      _this.processPointerDown = _this.processPointerDown.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerMove = _this.onPointerMove.bind(_this);\n      _this.processPointerMove = _this.processPointerMove.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerOut = _this.onPointerOut.bind(_this);\n      _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n\n      /**\n       * @private\n       * @member {Function}\n       */\n      _this.onPointerOver = _this.onPointerOver.bind(_this);\n\n      /**\n       * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n       * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n       * and functions are called instead of changing the CSS.\n       * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n       * @member {Object.<string, (string|Function|Object.<string, string>)>}\n       */\n      _this.cursorStyles = {\n        default: 'inherit',\n        pointer: 'pointer'\n      };\n\n      /**\n       * The mode of the cursor that is being used.\n       * The value of this is a key from the cursorStyles dictionary.\n       *\n       * @member {string}\n       */\n      _this.currentCursorMode = null;\n\n      /**\n       * Internal cached let.\n       *\n       * @private\n       * @member {string}\n       */\n      _this.cursor = null;\n\n      /**\n       * ray caster, for survey intersects from 3d-scene\n       *\n       * @private\n       * @member {Raycaster}\n       */\n      _this.raycaster = new three.Raycaster();\n\n      /**\n       * snippet time\n       *\n       * @private\n       * @member {Number}\n       */\n      _this._deltaTime = 0;\n      _this.setTargetElement(_this.renderer.domElement);\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n       * object.\n       *\n       * @event InteractionLayer#mousedown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * on the display object.\n       *\n       * @event InteractionLayer#rightdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released over the display\n       * object.\n       *\n       * @event InteractionLayer#mouseup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * over the display object.\n       *\n       * @event InteractionLayer#rightup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n       * the display object.\n       *\n       * @event InteractionLayer#click\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * and released on the display object.\n       *\n       * @event InteractionLayer#rightclick\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released outside the\n       * display object that initially registered a\n       * [mousedown]{@link InteractionLayer#event:mousedown}.\n       *\n       * @event InteractionLayer#mouseupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * outside the display object that initially registered a\n       * [rightdown]{@link InteractionLayer#event:rightdown}.\n       *\n       * @event InteractionLayer#rightupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved while over the display object\n       *\n       * @event InteractionLayer#mousemove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved onto the display object\n       *\n       * @event InteractionLayer#mouseover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved off the display object\n       *\n       * @event InteractionLayer#mouseout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed on the display object.\n       *\n       * @event InteractionLayer#pointerdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released over the display object.\n       *\n       * @event InteractionLayer#pointerup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a pointer event\n       *\n       * @event InteractionLayer#pointercancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed and released on the display object.\n       *\n       * @event InteractionLayer#pointertap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released outside the display object that initially\n       * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n       *\n       * @event InteractionLayer#pointerupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved while over the display object\n       *\n       * @event InteractionLayer#pointermove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved onto the display object\n       *\n       * @event InteractionLayer#pointerover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved off the display object\n       *\n       * @event InteractionLayer#pointerout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed on the display object.\n       *\n       * @event InteractionLayer#touchstart\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed from the display object.\n       *\n       * @event InteractionLayer#touchend\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a touch\n       *\n       * @event InteractionLayer#touchcancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed and removed from the display object.\n       *\n       * @event InteractionLayer#tap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed outside of the display object that initially\n       * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n       *\n       * @event InteractionLayer#touchendoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is moved along the display object.\n       *\n       * @event InteractionLayer#touchmove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n       * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mousedown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released over the display\n       * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n       * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#click\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n       * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightclick\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button (usually a mouse left-button) is released outside the\n       * display object that initially registered a\n       * [mousedown]{@link Object3D#event:mousedown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device secondary button (usually a mouse right-button) is released\n       * outside the display object that initially registered a\n       * [rightdown]{@link Object3D#event:rightdown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#rightupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved while over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mousemove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved onto the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device (usually a mouse) is moved off the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#mouseout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerdown\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerup\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a pointer event.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointercancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is pressed and released on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointertap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device button is released outside the display object that initially\n       * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerupoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved while over the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointermove\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved onto the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerover\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a pointer device is moved off the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#pointerout\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed on the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchstart\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed from the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchend\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when the operating system cancels a touch.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchcancel\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is placed and removed from the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#tap\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is removed outside of the display object that initially\n       * registered a [touchstart]{@link Object3D#event:touchstart}.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchendoutside\n       * @param {InteractionEvent} event - Interaction event\n       */\n\n      /**\n       * Fired when a touch point is moved along the display object.\n       * DisplayObject's `interactive` property must be set to `true` to fire event.\n       *\n       * @event Object3D#touchmove\n       * @param {InteractionEvent} event - Interaction event\n       */\n      return _this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n\n    createClass(InteractionLayer, [{\n      key: 'isAble',\n      value: function isAble() {\n        return this.layer && this.layer.interactive;\n      }\n\n      /**\n       * set layer\n       * @param {Layer} layer layer\n       */\n    }, {\n      key: 'setLayer',\n      value: function setLayer(layer) {\n        this.layer = layer;\n      }\n\n      /**\n       * Hit tests a point against the display tree, returning the first interactive object that is hit.\n       *\n       * @param {Point} globalPoint - A point to hit test with, in global space.\n       * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n       * to the last rendered root of the associated renderer.\n       * @return {Object3D} The hit display object, if any.\n       */\n    }, {\n      key: 'hitTest',\n      value: function hitTest(globalPoint, root) {\n        if (!this.isAble()) return null;\n        // clear the target for our hit test\n        hitTestEvent$1.target = null;\n        // assign the global point\n        hitTestEvent$1.data.global = globalPoint;\n        // ensure safety of the root\n        if (!root) {\n          root = this.layer.scene;\n        }\n        // run the hit test\n        this.processInteractive(hitTestEvent$1, root, null, true);\n        // return our found object - it'll be null if we didn't hit anything\n\n        return hitTestEvent$1.target;\n      }\n\n      /**\n       * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n       * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n       * another DOM element to receive those events.\n       *\n       * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n       */\n    }, {\n      key: 'setTargetElement',\n      value: function setTargetElement(element) {\n        this.removeEvents();\n        this.interactionDOMElement = element;\n        this.addEvents();\n      }\n\n      /**\n       * Registers all the DOM events\n       *\n       * @private\n       */\n    }, {\n      key: 'addEvents',\n      value: function addEvents() {\n        if (!this.interactionDOMElement || this.eventsAdded) {\n          return;\n        }\n        this.emit('addevents');\n        this.interactionDOMElement.addEventListener('click', this.onClick, true);\n        if (window.navigator.msPointerEnabled) {\n          this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n          this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n        } else if (this.supportsPointerEvents) {\n          this.interactionDOMElement.style['touch-action'] = 'none';\n        }\n\n        /**\n         * These events are added first, so that if pointer events are normalised, they are fired\n         * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents) {\n          window.document.addEventListener('pointermove', this.onPointerMove, true);\n          this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n          // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n          // we already handle those, so for the purposes of what we do in onPointerOut, we only\n          // care about the pointerleave event\n          this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n          this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n          window.addEventListener('pointercancel', this.onPointerCancel, true);\n          window.addEventListener('pointerup', this.onPointerUp, true);\n        } else {\n          window.document.addEventListener('mousemove', this.onPointerMove, true);\n          this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n          this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n          this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n          window.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents) {\n          this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n          this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n          this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n          this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n        this.eventsAdded = true;\n      }\n\n      /**\n       * Removes all the DOM events that were previously registered\n       *\n       * @private\n       */\n    }, {\n      key: 'removeEvents',\n      value: function removeEvents() {\n        if (!this.interactionDOMElement) {\n          return;\n        }\n        this.emit('removeevents');\n        this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n        if (window.navigator.msPointerEnabled) {\n          this.interactionDOMElement.style['-ms-content-zooming'] = '';\n          this.interactionDOMElement.style['-ms-touch-action'] = '';\n        } else if (this.supportsPointerEvents) {\n          this.interactionDOMElement.style['touch-action'] = '';\n        }\n        if (this.supportsPointerEvents) {\n          window.document.removeEventListener('pointermove', this.onPointerMove, true);\n          this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n          this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n          window.removeEventListener('pointercancel', this.onPointerCancel, true);\n          window.removeEventListener('pointerup', this.onPointerUp, true);\n        } else {\n          window.document.removeEventListener('mousemove', this.onPointerMove, true);\n          this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n          this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n          window.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n        if (this.supportsTouchEvents) {\n          this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n          this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n          this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n          this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n        this.interactionDOMElement = null;\n        this.eventsAdded = false;\n      }\n\n      /**\n       * Updates the state of interactive objects.\n       * Invoked by a throttled ticker.\n       *\n       * @param {number} deltaTime - time delta since last tick\n       */\n    }, {\n      key: 'update',\n      value: function update(_ref) {\n        var snippet = _ref.snippet;\n        if (!this.isAble()) return;\n        this._deltaTime += snippet;\n        if (this._deltaTime < this.interactionFrequency) {\n          return;\n        }\n        this._deltaTime = 0;\n        if (!this.interactionDOMElement) {\n          return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this.didMove) {\n          this.didMove = false;\n          return;\n        }\n        this.cursor = null;\n\n        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n        // but there was a scenario of a display object moving under a static mouse cursor.\n        // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n        for (var k in this.activeInteractionData) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (this.activeInteractionData.hasOwnProperty(k)) {\n            var interactionData = this.activeInteractionData[k];\n            if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n              var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n              this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);\n            }\n          }\n        }\n        this.setCursorMode(this.cursor);\n\n        // TODO\n      }\n\n      /**\n       * Sets the current cursor mode, handling any callbacks or CSS style changes.\n       *\n       * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n       */\n    }, {\n      key: 'setCursorMode',\n      value: function setCursorMode(mode) {\n        mode = mode || 'default';\n        // if the mode didn't actually change, bail early\n        if (this.currentCursorMode === mode) {\n          return;\n        }\n        this.currentCursorMode = mode;\n        var style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style) {\n          switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n            case 'string':\n              // string styles are handled as cursor CSS\n              this.interactionDOMElement.style.cursor = style;\n              break;\n            case 'function':\n              // functions are just called, and passed the cursor mode\n              style(mode);\n              break;\n            case 'object':\n              // if it is an object, assume that it is a dictionary of CSS styles,\n              // apply it to the interactionDOMElement\n              Object.assign(this.interactionDOMElement.style, style);\n              break;\n            default:\n              break;\n          }\n        } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n          // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n          // for the mode, then assume that the dev wants it to be CSS for the cursor.\n          this.interactionDOMElement.style.cursor = mode;\n        }\n      }\n\n      /**\n       * Dispatches an event on the display object that was interacted with\n       *\n       * @param {Object3D} displayObject - the display object in question\n       * @param {string} eventString - the name of the event (e.g, mousedown)\n       * @param {object} eventData - the event data object\n       * @private\n       */\n    }, {\n      key: 'triggerEvent',\n      value: function triggerEvent(displayObject, eventString, eventData) {\n        if (!eventData.stopped) {\n          eventData.currentTarget = displayObject;\n          eventData.type = eventString;\n          displayObject.emit(eventString, eventData);\n          if (displayObject[eventString]) {\n            displayObject[eventString](eventData);\n          }\n        }\n      }\n\n      /**\n       * This function is provides a neat way of crawling through the scene graph and running a\n       * specified function on all interactive objects it finds. It will also take care of hit\n       * testing the interactive objects and passes the hit across in the function.\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - event containing the point that\n       *  is tested for collision\n       * @param {Object3D} displayObject - the displayObject\n       *  that will be hit test (recursively crawls its children)\n       * @param {Function} [func] - the function that will be called on each interactive object. The\n       *  interactionEvent, displayObject and hit will be passed to the function\n       * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n       * @param {boolean} [interactive] - Whether the displayObject is interactive\n       * @return {boolean} returns true if the displayObject hit the point\n       */\n    }, {\n      key: 'processInteractive',\n      value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n        if (!displayObject || !displayObject.visible) {\n          return false;\n        }\n\n        // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n        //\n        // This function will now loop through all objects and then only hit test the objects it HAS\n        // to, not all of them. MUCH faster..\n        // An object will be hit test if the following is true:\n        //\n        // 1: It is interactive.\n        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n        //\n        // As another little optimisation once an interactive object has been hit we can carry on\n        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n        // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n        interactive = displayObject.interactive || interactive;\n        var hit = false;\n        var interactiveParent = interactive;\n        if (displayObject.interactiveChildren && displayObject.children) {\n          var children = displayObject.children;\n          for (var i = children.length - 1; i >= 0; i--) {\n            var child = children[i];\n\n            // time to get recursive.. if this function will return if something is hit..\n            var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n            if (childHit) {\n              // its a good idea to check if a child has lost its parent.\n              // this means it has been removed whilst looping so its best\n              if (!child.parent) {\n                continue;\n              }\n\n              // we no longer need to hit test any more objects in this container as we we\n              // now know the parent has been hit\n              interactiveParent = false;\n\n              // If the child is interactive , that means that the object hit was actually\n              // interactive and not just the child of an interactive object.\n              // This means we no longer need to hit test anything else. We still need to run\n              // through all objects, but we don't need to perform any hit tests.\n\n              if (childHit) {\n                if (interactionEvent.target) {\n                  hitTest = false;\n                }\n                hit = true;\n              }\n            }\n          }\n        }\n\n        // no point running this if the item is not interactive or does not have an interactive parent.\n        if (interactive) {\n          // if we are hit testing (as in we have no hit any objects yet)\n          // We also don't need to worry about hit testing if once of the displayObjects children\n          // has already been hit - but only if it was interactive, otherwise we need to keep\n          // looking for an interactive child, just in case we hit one\n          if (hitTest && !interactionEvent.target) {\n            if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n              hit = true;\n            }\n          }\n          if (displayObject.interactive) {\n            if (hit && !interactionEvent.target) {\n              interactionEvent.data.target = interactionEvent.target = displayObject;\n            }\n            if (func) {\n              func(interactionEvent, displayObject, !!hit);\n            }\n          }\n        }\n        return hit;\n      }\n\n      /**\n       * Is called when the click is pressed down on the renderer element\n       *\n       * @private\n       * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n       */\n    }, {\n      key: 'onClick',\n      value: function onClick(originalEvent) {\n        if (!this.isAble()) return;\n        if (originalEvent.type !== 'click') return;\n        var events = this.normalizeToPointerData(originalEvent);\n        if (this.autoPreventDefault && events[0].isNormalized) {\n          originalEvent.preventDefault();\n        }\n        var interactionData = this.getInteractionDataForPointerId(events[0]);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n        this.emit('click', interactionEvent);\n      }\n\n      /**\n       * Processes the result of the click check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processClick',\n      value: function processClick(interactionEvent, displayObject, hit) {\n        if (hit) {\n          this.triggerEvent(displayObject, 'click', interactionEvent);\n        }\n      }\n\n      /**\n       * Is called when the pointer button is pressed down on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n       */\n    }, {\n      key: 'onPointerDown',\n      value: function onPointerDown(originalEvent) {\n        if (!this.isAble()) return;\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n\n        /**\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && events[0].isNormalized) {\n          originalEvent.preventDefault();\n        }\n        var eventLen = events.length;\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n          this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n          this.emit('pointerdown', interactionEvent);\n          if (event.pointerType === 'touch') {\n            this.emit('touchstart', interactionEvent);\n          } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n            var isRightButton = event.button === 2;\n            this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n          }\n        }\n      }\n\n      /**\n       * Processes the result of the pointer down check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerDown',\n      value: function processPointerDown(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        if (hit) {\n          if (!displayObject.trackedPointers[id]) {\n            displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n          }\n          this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n          if (data.pointerType === 'touch') {\n            displayObject.started = true;\n            this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n          } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n            var isRightButton = data.button === 2;\n            if (isRightButton) {\n              displayObject.trackedPointers[id].rightDown = true;\n            } else {\n              displayObject.trackedPointers[id].leftDown = true;\n            }\n            this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is released on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n       * @param {boolean} cancelled - true if the pointer is cancelled\n       * @param {Function} func - Function passed to {@link processInteractive}\n       */\n    }, {\n      key: 'onPointerComplete',\n      value: function onPointerComplete(originalEvent, cancelled, func) {\n        var events = this.normalizeToPointerData(originalEvent);\n        var eventLen = events.length;\n\n        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n        // in all cases (unless it was a pointercancel)\n        var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n\n          // perform hit testing for events targeting our canvas or cancel events\n          this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n          this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n          if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n            var isRightButton = event.button === 2;\n            this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n          } else if (event.pointerType === 'touch') {\n            this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n            this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is cancelled\n       *\n       * @private\n       * @param {PointerEvent} event - The DOM event of a pointer button being released\n       */\n    }, {\n      key: 'onPointerCancel',\n      value: function onPointerCancel(event) {\n        if (!this.isAble()) return;\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n        this.onPointerComplete(event, true, this.processPointerCancel);\n      }\n\n      /**\n       * Processes the result of the pointer cancel check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       */\n    }, {\n      key: 'processPointerCancel',\n      value: function processPointerCancel(interactionEvent, displayObject) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        if (displayObject.trackedPointers[id] !== undefined) {\n          delete displayObject.trackedPointers[id];\n          this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n          if (data.pointerType === 'touch') {\n            this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer button is released on the renderer element\n       *\n       * @private\n       * @param {PointerEvent} event - The DOM event of a pointer button being released\n       */\n    }, {\n      key: 'onPointerUp',\n      value: function onPointerUp(event) {\n        if (!this.isAble()) return;\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n        this.onPointerComplete(event, false, this.processPointerUp);\n      }\n\n      /**\n       * Processes the result of the pointer up check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerUp',\n      value: function processPointerUp(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        var trackingData = displayObject.trackedPointers[id];\n        var isTouch = data.pointerType === 'touch';\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n        // Mouse only\n        if (isMouse) {\n          var isRightButton = data.button === 2;\n          var flags = InteractionTrackingData.FLAGS;\n          var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n          var isDown = trackingData !== undefined && trackingData.flags & test;\n          if (hit) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n            if (isDown) {\n              this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n            }\n          } else if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n          }\n          // update the down state of the tracking data\n          if (trackingData) {\n            if (isRightButton) {\n              trackingData.rightDown = false;\n            } else {\n              trackingData.leftDown = false;\n            }\n          }\n        }\n\n        // Pointers and Touches, and Mouse\n        if (isTouch && displayObject.started) {\n          displayObject.started = false;\n          this.triggerEvent(displayObject, 'touchend', interactionEvent);\n        }\n        if (hit) {\n          this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n          if (trackingData) {\n            this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n            if (isTouch) {\n              this.triggerEvent(displayObject, 'tap', interactionEvent);\n              // touches are no longer over (if they ever were) when we get the touchend\n              // so we should ensure that we don't keep pretending that they are\n              trackingData.over = false;\n            }\n          }\n        } else if (trackingData) {\n          this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n          if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n        }\n        // Only remove the tracking data if there is no over/down state still associated with it\n        if (trackingData && trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n\n      /**\n       * Is called when the pointer moves across the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n       */\n    }, {\n      key: 'onPointerMove',\n      value: function onPointerMove(originalEvent) {\n        if (!this.isAble()) return;\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n        if (events[0].pointerType === 'mouse') {\n          this.didMove = true;\n          this.cursor = null;\n        }\n        var eventLen = events.length;\n        for (var i = 0; i < eventLen; i++) {\n          var event = events[i];\n          var interactionData = this.getInteractionDataForPointerId(event);\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n          interactionEvent.data.originalEvent = originalEvent;\n          var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n          this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);\n          this.emit('pointermove', interactionEvent);\n          if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n          if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n        }\n        if (events[0].pointerType === 'mouse') {\n          this.setCursorMode(this.cursor);\n\n          // TODO BUG for parents interactive object (border order issue)\n        }\n      }\n\n      /**\n       * Processes the result of the pointer move check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerMove',\n      value: function processPointerMove(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var isTouch = data.pointerType === 'touch';\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n        if (isMouse) {\n          this.processPointerOverOut(interactionEvent, displayObject, hit);\n        }\n        if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n        if (!this.moveWhenInside || hit) {\n          this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n          if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n        }\n      }\n\n      /**\n       * Is called when the pointer is moved out of the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n       */\n    }, {\n      key: 'onPointerOut',\n      value: function onPointerOut(originalEvent) {\n        if (!this.isAble()) return;\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n        var events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOut, so events will always be length 1\n        var event = events[0];\n        if (event.pointerType === 'mouse') {\n          this.mouseOverRenderer = false;\n          this.setCursorMode(null);\n        }\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = event;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n        this.emit('pointerout', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          this.emit('mouseout', interactionEvent);\n        } else {\n          // we can get touchleave events after touchend, so we want to make sure we don't\n          // introduce memory leaks\n          this.releaseInteractionDataForPointerId(interactionData.identifier);\n        }\n      }\n\n      /**\n       * Processes the result of the pointer over/out check and dispatches the event if need be\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n       * @param {Object3D} displayObject - The display object that was tested\n       * @param {boolean} hit - the result of the hit test on the display object\n       */\n    }, {\n      key: 'processPointerOverOut',\n      value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n        var data = interactionEvent.data;\n        var id = interactionEvent.data.identifier;\n        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n        var trackingData = displayObject.trackedPointers[id];\n\n        // if we just moused over the display object, then we need to track that state\n        if (hit && !trackingData) {\n          trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n        if (trackingData === undefined) return;\n        if (hit && this.mouseOverRenderer) {\n          if (!trackingData.over) {\n            trackingData.over = true;\n            this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n            if (isMouse) {\n              this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n            }\n          }\n\n          // only change the cursor if it has not already been changed (by something deeper in the\n          // display tree)\n          if (isMouse && this.cursor === null) {\n            this.cursor = displayObject.cursor;\n          }\n        } else if (trackingData.over) {\n          trackingData.over = false;\n          this.triggerEvent(displayObject, 'pointerout', this.eventData);\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n          }\n          // if there is no mouse down information for the pointer, then it is safe to delete\n          if (trackingData.none) {\n            delete displayObject.trackedPointers[id];\n          }\n        }\n      }\n\n      /**\n       * Is called when the pointer is moved into the renderer element\n       *\n       * @private\n       * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n       */\n    }, {\n      key: 'onPointerOver',\n      value: function onPointerOver(originalEvent) {\n        if (!this.isAble()) return;\n        var events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOver, so events will always be length 1\n        var event = events[0];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = event;\n        if (event.pointerType === 'mouse') {\n          this.mouseOverRenderer = true;\n        }\n        this.emit('pointerover', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          this.emit('mouseover', interactionEvent);\n        }\n      }\n\n      /**\n       * Get InteractionData for a given pointerId. Store that data as well\n       *\n       * @private\n       * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n       * @return {InteractionData} - Interaction data for the given pointer identifier\n       */\n    }, {\n      key: 'getInteractionDataForPointerId',\n      value: function getInteractionDataForPointerId(event) {\n        var pointerId = event.pointerId;\n        var interactionData = void 0;\n        if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === 'mouse') {\n          interactionData = this.mouse;\n        } else if (this.activeInteractionData[pointerId]) {\n          interactionData = this.activeInteractionData[pointerId];\n        } else {\n          interactionData = this.interactionDataPool.pop() || new InteractionData();\n          interactionData.identifier = pointerId;\n          this.activeInteractionData[pointerId] = interactionData;\n        }\n        // copy properties from the event, so that we can make sure that touch/pointer specific\n        // data is available\n        interactionData._copyEvent(event);\n        return interactionData;\n      }\n\n      /**\n       * Return unused InteractionData to the pool, for a given pointerId\n       *\n       * @private\n       * @param {number} pointerId - Identifier from a pointer event\n       */\n    }, {\n      key: 'releaseInteractionDataForPointerId',\n      value: function releaseInteractionDataForPointerId(pointerId) {\n        var interactionData = this.activeInteractionData[pointerId];\n        if (interactionData) {\n          delete this.activeInteractionData[pointerId];\n          interactionData._reset();\n          this.interactionDataPool.push(interactionData);\n        }\n      }\n\n      /**\n       * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n       * resulting value is stored in the point. This takes into account the fact that the DOM\n       * element could be scaled and positioned anywhere on the screen.\n       *\n       * @param  {Vector2} point - the point that the result will be stored in\n       * @param  {number} x - the x coord of the position to map\n       * @param  {number} y - the y coord of the position to map\n       */\n    }, {\n      key: 'mapPositionToPoint',\n      value: function mapPositionToPoint(point, x, y) {\n        var rect = void 0;\n\n        // IE 11 fix\n        if (!this.interactionDOMElement.parentElement) {\n          rect = {\n            x: 0,\n            y: 0,\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n          };\n        } else {\n          rect = this.interactionDOMElement.getBoundingClientRect();\n        }\n        point.x = (x - rect.left) / rect.width * 2 - 1;\n        point.y = -((y - rect.top) / rect.height) * 2 + 1;\n      }\n\n      /**\n       * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n       *\n       * @private\n       * @param {InteractionEvent} interactionEvent - The event to be configured\n       * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n       * @param {InteractionData} interactionData - The InteractionData that will be paired\n       *        with the InteractionEvent\n       * @return {InteractionEvent} the interaction event that was passed in\n       */\n    }, {\n      key: 'configureInteractionEventForDOMEvent',\n      value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n        interactionEvent.data = interactionData;\n        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n        if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n        // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n        if (pointerEvent.pointerType === 'touch') {\n          pointerEvent.globalX = interactionData.global.x;\n          pointerEvent.globalY = interactionData.global.y;\n        }\n        interactionData.originalEvent = pointerEvent;\n        interactionEvent._reset();\n        interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n        return interactionEvent;\n      }\n\n      /**\n       * Ensures that the original event object contains all data that a regular pointer event would have\n       *\n       * @private\n       * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n       * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n       */\n    }, {\n      key: 'normalizeToPointerData',\n      value: function normalizeToPointerData(event) {\n        var normalizedEvents = [];\n        if (this.supportsTouchEvents && event instanceof TouchEvent) {\n          for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n            var touch = event.changedTouches[i];\n            if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n            if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n            if (typeof touch.isPrimary === 'undefined') {\n              touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n            }\n            if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n            if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n            if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n            if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n            if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n            if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n            if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n            touch.twist = 0;\n            touch.tangentialPressure = 0;\n            // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n            // support, and the fill ins are not quite the same\n            // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n            // left is not 0,0 on the page\n            if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n            if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n            // mark the touch as normalized, just so that we know we did it\n            touch.isNormalized = true;\n            normalizedEvents.push(touch);\n          }\n        } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n          if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n          if (typeof event.width === 'undefined') event.width = 1;\n          if (typeof event.height === 'undefined') event.height = 1;\n          if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n          if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n          if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n          if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID$1;\n          if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n          event.twist = 0;\n          event.tangentialPressure = 0;\n\n          // mark the mouse event as normalized, just so that we know we did it\n          event.isNormalized = true;\n          normalizedEvents.push(event);\n        } else {\n          normalizedEvents.push(event);\n        }\n        return normalizedEvents;\n      }\n\n      /**\n       * Destroys the interaction manager\n       *\n       */\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeEvents();\n        this.removeAllListeners();\n        this.renderer = null;\n        this.mouse = null;\n        this.eventData = null;\n        this.interactionDOMElement = null;\n        this.onPointerDown = null;\n        this.processPointerDown = null;\n        this.onPointerUp = null;\n        this.processPointerUp = null;\n        this.onPointerCancel = null;\n        this.processPointerCancel = null;\n        this.onPointerMove = null;\n        this.processPointerMove = null;\n        this.onPointerOut = null;\n        this.processPointerOverOut = null;\n        this.onPointerOver = null;\n        this._tempPoint = null;\n      }\n    }]);\n    return InteractionLayer;\n  }(three.EventDispatcher);\n  (function () {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n    if (!window.requestAnimationFrame) {\n      window.requestAnimationFrame = function (callback) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n    if (!window.cancelAnimationFrame) {\n      window.cancelAnimationFrame = function (id) {\n        clearTimeout(id);\n      };\n    }\n    window.RAF = window.requestAnimationFrame;\n    window.CAF = window.cancelAnimationFrame;\n  })();\n\n  /**\n   * @extends EventDispatcher\n   */\n\n  var Ticker = function (_EventDispatcher) {\n    inherits(Ticker, _EventDispatcher);\n\n    /**\n     *\n     */\n    function Ticker() {\n      classCallCheck(this, Ticker);\n      var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));\n      _this.timer = null;\n      _this.started = false;\n\n      /**\n       * pre-time cache\n       *\n       * @member {Number}\n       * @private\n       */\n      _this.pt = 0;\n\n      /**\n       * how long the time through, at this tick\n       *\n       * @member {Number}\n       * @private\n       */\n      _this.snippet = 0;\n      _this.start();\n      return _this;\n    }\n\n    /**\n     * start tick loop\n     */\n\n    createClass(Ticker, [{\n      key: 'start',\n      value: function start() {\n        var _this2 = this;\n        if (this.started) return;\n        var loop = function loop() {\n          _this2.timeline();\n          _this2.emit('tick', {\n            snippet: _this2.snippet\n          });\n          _this2.timer = RAF(loop);\n        };\n        loop();\n      }\n\n      /**\n       * stop tick loop\n       */\n    }, {\n      key: 'stop',\n      value: function stop() {\n        CAF(this.timer);\n        this.started = false;\n      }\n\n      /**\n       * get timeline snippet\n       *\n       * @private\n       */\n    }, {\n      key: 'timeline',\n      value: function timeline() {\n        this.snippet = Date.now() - this.pt;\n        if (this.pt === 0 || this.snippet > 200) {\n          this.pt = Date.now();\n          this.snippet = Date.now() - this.pt;\n        }\n        this.pt += this.snippet;\n      }\n    }]);\n    return Ticker;\n  }(three.EventDispatcher);\n\n  /**\n   * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n   * if its interactive parameter is set to true\n   * This manager also supports multitouch.\n   *\n   * reference to [pixi.js](http://www.pixijs.com/) impl\n   *\n   * @example\n   * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n   * import { Interaction } from 'three.interaction';\n   * const renderer = new WebGLRenderer({ canvas: canvasElement });\n   * const scene = new Scene();\n   * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n   *\n   * const interaction = new Interaction(renderer, scene, camera);\n   * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n   * const cube = new Mesh(\n   *   new BoxGeometry(1, 1, 1),\n   *   new MeshBasicMaterial({ color: 0xffffff }),\n   * );\n   * scene.add(cube);\n   * cube.on('touchstart', ev => {\n   *   console.log(ev);\n   * });\n   *\n   * cube.on('mousedown', ev => {\n   *   console.log(ev);\n   * });\n   *\n   * cube.on('pointerdown', ev => {\n   *   console.log(ev);\n   * });\n   * // and so on ...\n   *\n   * // you can also listen on parent-node or any display-tree node,\n   * // source event will bubble up along with display-tree.\n   * // you can stop the bubble-up by invoke ev.stopPropagation function.\n   * scene.on('touchstart', ev => {\n   *   console.log(ev);\n   * })\n   *\n   * @class\n   * @extends InteractionManager\n   */\n\n  var Interaction = function (_InteractionManager) {\n    inherits(Interaction, _InteractionManager);\n\n    /**\n     * @param {WebGLRenderer} renderer - A reference to the current renderer\n     * @param {Scene} scene - A reference to the current scene\n     * @param {Camera} camera - A reference to the current camera\n     * @param {Object} [options] - The options for the manager.\n     * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n     * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n     * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n     */\n    function Interaction(renderer, scene, camera, options) {\n      classCallCheck(this, Interaction);\n      options = Object.assign({\n        autoAttach: false\n      }, options);\n\n      /**\n       * a ticker\n       *\n       * @private\n       * @member {Ticker}\n       */\n      var _this = possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this, renderer, scene, camera, options));\n      _this.ticker = new Ticker();\n\n      /**\n       * update for some over event\n       *\n       * @private\n       */\n      _this.update = _this.update.bind(_this);\n      _this.on('addevents', function () {\n        _this.ticker.on('tick', _this.update);\n      });\n      _this.on('removeevents', function () {\n        _this.ticker.off('tick', _this.update);\n      });\n      _this.setTargetElement(_this.renderer.domElement);\n      return _this;\n    }\n    return Interaction;\n  }(InteractionManager);\n  exports.InteractionManager = InteractionManager;\n  exports.InteractionLayer = InteractionLayer;\n  exports.Interaction = Interaction;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["_rt","val","Object","prototype","toString","call","Utils","ks","variable","isUndefined","three","EventDispatcher","on","type","fn","isFunction","Object3D","interactive","addEventListener","off","removeEventListener","once","cb","ev","emit","_listeners","undefined","cbs","cache","slice","argument","Array","_len","_key","arguments","i","length","apply","interactiveChildren","started","defineProperty","get","_trackedPointers","raycastTest","raycaster","result","raycast","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","event","InteractionEvent","stopped","currentTarget","data","intersects","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","_EventDispatcher","renderer","scene","camera","options","autoPreventDefault","interactionFrequency","mouse","set","activeInteractionData","_this","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","window","supportsPointerEvents","PointerEvent","onClick","bind","processClick","onPointerUp","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","_deltaTime","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","snippet","_ref","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","_typeof","assign","displayObject","eventString","func","hitTest","visible","hit","interactiveParent","children","child","childHit","parent","object","events","normalizeToPointerData","isNormalized","preventDefault","getInteractionDataForPointerId","triggerEvent","eventLen","isRightButton","id","trackedPointers","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","point","x","y","rect","parentElement","getBoundingClientRect","left","top","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","intersectObjects","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint","MOUSE_POINTER_ID$1","hitTestEvent$1","InteractionLayer","layer","isAble","lastTime","vendors","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","setTimeout","RAF","CAF","Ticker","timer","pt","start","loop","timeline","_this2","now","Interaction","_InteractionManager","autoAttach","ticker","update"],"sources":["C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\utils\\Utils.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\patch\\EventDispatcher.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\patch\\Object3D.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\InteractionData.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\InteractionEvent.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\InteractionTrackingData.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\InteractionManager.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\InteractionLayer.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\utils\\Raf.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\utils\\Ticker.js","C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three.interaction\\src\\interaction\\Interaction.js"],"sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n","import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n","import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n","(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}