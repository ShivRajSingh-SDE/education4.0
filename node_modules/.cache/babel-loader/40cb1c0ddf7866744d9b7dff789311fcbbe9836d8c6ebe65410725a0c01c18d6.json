{"ast":null,"code":"import { ShaderMaterial as e, Color as r, Face3 as o, BackSide as n, Mesh as i } from \"three\";\nvar t = {\n  backside: !0,\n  coefficient: .5,\n  color: \"gold\",\n  size: 2,\n  power: 1\n};\nfunction a(o, n, i) {\n  return new e({\n    depthWrite: !1,\n    fragmentShader: \"\\nuniform vec3 color;\\nuniform float coefficient;\\nuniform float power;\\nvarying vec3 vVertexNormal;\\nvarying vec3 vVertexWorldPosition;\\nvoid main() {\\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\\n  vec3 viewCameraToVertex\\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\\n  viewCameraToVertex = normalize(viewCameraToVertex);\\n  float intensity\\t= pow(\\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\\n    power\\n  );\\n  gl_FragColor = vec4(color, intensity);\\n}\",\n    transparent: !0,\n    uniforms: {\n      coefficient: {\n        value: o\n      },\n      color: {\n        value: new r(n)\n      },\n      power: {\n        value: i\n      }\n    },\n    vertexShader: \"\\nvarying vec3 vVertexWorldPosition;\\nvarying vec3 vVertexNormal;\\nvoid main() {\\n  vVertexNormal\\t= normalize(normalMatrix * normal);\\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\\n  gl_Position\\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\"\n  });\n}\nfunction c(e, r) {\n  var n = e.clone(),\n    i = new Array(n.vertices.length);\n  return n.faces.forEach(function (e) {\n    e instanceof o ? (i[e.a] = e.vertexNormals[0], i[e.b] = e.vertexNormals[1], i[e.c] = e.vertexNormals[2]) : console.error(\"Face needs to be an instance of THREE.Face3.\");\n  }), n.vertices.forEach(function (e, o) {\n    var n = i[o],\n      t = n.y,\n      a = n.z;\n    e.x += n.x * r, e.y += t * r, e.z += a * r;\n  }), n;\n}\nfunction v(e, r) {\n  void 0 === r && (r = t);\n  var o = r.backside,\n    v = r.coefficient,\n    l = r.color,\n    f = r.power,\n    m = c(e, r.size),\n    x = a(v, l, f);\n  return o && (x.side = n), new i(m, x);\n}\nexport { c as createGlowGeometry, a as createGlowMaterial, v as createGlowMesh, t as defaultOptions };","map":{"version":3,"names":["t","backside","coefficient","color","size","power","a","o","n","i","e","depthWrite","fragmentShader","transparent","uniforms","value","r","vertexShader","c","clone","Array","vertices","length","faces","forEach","vertexNormals","b","console","error","y","z","x","v","l","f","m","side","createGlowGeometry","createGlowMaterial","createGlowMesh","defaultOptions"],"sources":["C:\\Users\\shivr\\Downloads\\2\\Shiv\\node_modules\\three-glow-mesh\\index.js"],"sourcesContent":["import { BackSide, Color, Face3, Mesh, ShaderMaterial } from 'three';\n\nconst fragmentShader = `\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}`;\n\nconst vertexShader = `\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nexport const defaultOptions = {\n  backside: true,\n  coefficient: 0.5,\n  color: 'gold',\n  size: 2,\n  power: 1,\n};\n\n// Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\nexport function createGlowMaterial(coefficient, color, power) {\n  return new ShaderMaterial({\n    depthWrite: false,\n    fragmentShader,\n    transparent: true,\n    uniforms: {\n      coefficient: {\n        value: coefficient,\n      },\n      color: {\n        value: new Color(color),\n      },\n      power: {\n        value: power,\n      },\n    },\n    vertexShader,\n  });\n}\n\nexport function createGlowGeometry(geometry, size) {\n  // Gather vertexNormals from geometry.faces\n  const glowGeometry = geometry.clone();\n  const vertexNormals = new Array(glowGeometry.vertices.length);\n  glowGeometry.faces.forEach((face) => {\n    if (face instanceof Face3) {\n      vertexNormals[face.a] = face.vertexNormals[0];\n      vertexNormals[face.b] = face.vertexNormals[1];\n      vertexNormals[face.c] = face.vertexNormals[2];\n    } else {\n      console.error('Face needs to be an instance of THREE.Face3.');\n    }\n  });\n\n  // Modify the vertices according to vertexNormal\n  glowGeometry.vertices.forEach((vertex, i) => {\n    const { x, y, z } = vertexNormals[i];\n    vertex.x += x * size;\n    vertex.y += y * size;\n    vertex.z += z * size;\n  });\n\n  return glowGeometry;\n}\n\nexport function createGlowMesh(geometry, options = defaultOptions) {\n  const { backside, coefficient, color, size, power } = options;\n\n  const glowGeometry = createGlowGeometry(geometry, size);\n  const glowMaterial = createGlowMaterial(coefficient, color, power);\n\n  if (backside) {\n    glowMaterial.side = BackSide;\n  }\n\n  return new Mesh(glowGeometry, glowMaterial);\n}\n"],"mappings":";AAEA,IA2BaA,CAAA,GAAiB;EAC5BC,QAAA,GAAU;EACVC,WAAA,EAAa;EACbC,KAAA,EAAO;EACPC,IAAA,EAAM;EACNC,KAAA,EAAO;AAAA;AAAA,SAIOC,EAAmBC,CAAA,EAAaC,CAAA,EAAOC,CAAA;EACrD,WAAWC,CAAA,CAAe;IACxBC,UAAA,GAAY;IACZC,cAAA;IACAC,WAAA,GAAa;IACbC,QAAA,EAAU;MACRZ,WAAA,EAAa;QACXa,KAAA,EAAOR;MAAA;MAETJ,KAAA,EAAO;QACLY,KAAA,EAAO,IAAIC,CAAA,CAAMR,CAAA;MAAA;MAEnBH,KAAA,EAAO;QACLU,KAAA,EAAON;MAAA;IAAA;IAGXQ,YAAA;EAAA;AAAA;AAAA,SAIYC,EAAmBR,CAAA,EAAUM,CAAA;EAE3C,IAAMR,CAAA,GAAeE,CAAA,CAASS,KAAA;IACxBV,CAAA,GAAgB,IAAIW,KAAA,CAAMZ,CAAA,CAAaa,QAAA,CAASC,MAAA;EAmBtD,OAlBAd,CAAA,CAAae,KAAA,CAAMC,OAAA,CAAQ,UAACd,CAAA;IACtBA,CAAA,YAAgBH,CAAA,IAClBE,CAAA,CAAcC,CAAA,CAAKJ,CAAA,IAAKI,CAAA,CAAKe,aAAA,CAAc,IAC3ChB,CAAA,CAAcC,CAAA,CAAKgB,CAAA,IAAKhB,CAAA,CAAKe,aAAA,CAAc,IAC3ChB,CAAA,CAAcC,CAAA,CAAKQ,CAAA,IAAKR,CAAA,CAAKe,aAAA,CAAc,MAE3CE,OAAA,CAAQC,KAAA,CAAM;EAAA,IAKlBpB,CAAA,CAAaa,QAAA,CAASG,OAAA,CAAQ,UAACd,CAAA,EAAQH,CAAA;IAAA,IAAAC,CAAA,GACjBC,CAAA,CAAcF,CAAA;MAAvBP,CAAA,GAAAQ,CAAA,CAAAqB,CAAA;MAAGvB,CAAA,GAAAE,CAAA,CAAAsB,CAAA;IACdpB,CAAA,CAAOqB,CAAA,IAAAvB,CAAA,CADCuB,CAAA,GACQf,CAAA,EAChBN,CAAA,CAAOmB,CAAA,IAAK7B,CAAA,GAAIgB,CAAA,EAChBN,CAAA,CAAOoB,CAAA,IAAKxB,CAAA,GAAIU,CAAA;EAAA,IAGXR,CAAA;AAAA;AAAA,SAGOwB,EAAetB,CAAA,EAAUM,CAAA;EAAA,WAAAA,CAAA,KAAAA,CAAA,GAAUhB,CAAA;EAAA,IACzCO,CAAA,GAA8CS,CAAA,CAA9Cf,QAAA;IAAU+B,CAAA,GAAoChB,CAAA,CAApCd,WAAA;IAAa+B,CAAA,GAAuBjB,CAAA,CAAvBb,KAAA;IAAa+B,CAAA,GAAUlB,CAAA,CAAVX,KAAA;IAEtC8B,CAAA,GAAejB,CAAA,CAAmBR,CAAA,EAFcM,CAAA,CAAhBZ,IAAA;IAGhC2B,CAAA,GAAezB,CAAA,CAAmB0B,CAAA,EAAaC,CAAA,EAAOC,CAAA;EAM5D,OAJI3B,CAAA,KACFwB,CAAA,CAAaK,IAAA,GAAO5B,CAAA,OAGXC,CAAA,CAAK0B,CAAA,EAAcJ,CAAA;AAAA;AAAA,SAAAb,CAAA,IAAAmB,kBAAA,EAAA/B,CAAA,IAAAgC,kBAAA,EAAAN,CAAA,IAAAO,cAAA,EAAAvC,CAAA,IAAAwC,cAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}